SOLID PRINCIPLES
----------------
1)---> Single Responsibility Principle (SRP) states that a class should have only one reason to change.
It means the class should handle only one responsibility or job. 
//Valid Example for single responsibility
-----------------------------------------
class WatchMan
{
    void openDoor()
    {
        System.out.println("Open a door...");
    }
}

class Receptionist
{
    void getDetails()
    {
        System.out.println("Enter the valid details...");
    }
}

class RoomBoy
{
    void serveLunch()
    {
        System.out.println("Go and get my lunch...");
    }
}

class Cleaner
{
    void clean()
    {
        System.out.println("Clean a room...");
    }
}

public class Employee
{
    public static void main(String [] args)
    {
        WatchMan watchman=new WatchMan();
        watchman.openDoor();
        Receptionist receptionist=new Receptionist();
        receptionist.getDetails();
        RoomBoy roomboy=new RoomBoy();
        roomboy.serveLunch();
        Cleaner cleaner=new Cleaner();
        cleaner.clean();
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Invalid Example for single responsiblity:
----------------------------------------
public class Employee
{
    private void watchMan()
    {
        System.out.println("Open the door...");
    }
    
    private void receptionist()
    {
        System.out.println("Enter the details...");
    }
    
    private void roomBoy()
    {
        System.out.println("Carry on my lugguage...");
    }
    
    private void cleaner()
    {
        System.out.println("Clean the rooms...");
    }
    
    public static void main(String [] args)
    {
        Employee employee=new Employee();
        employee.watchMan();
        employee.receptionist();
        employee.roomBoy();
        employee.cleaner();
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2)---->Open/Closed Principle (OCP)
---------------------------
-----> A class should be open for extension (you can add new behavior) but closed for modification (you shouldn’t change existing code to add it).

Example for invalid OCP principle:
----------------------------------

public class Payment
{
    private void cashPay()
    {
        System.out.println("Cash on delivery");
    }
    private void UPIpayment()
    {
        System.out.println("Online Payment");
    }
    private void walletPayment()
    {
        System.out.println("Wallet Payment");
    }
    public static void main (String [] args)
    {
        Payment payment=new Payment();
        payment.cashPay();
        payment.UPIpayment();
        payment.walletPayment();
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Valid Example for OCP principle :
---------------------------------

interface  Payable {
    void pay();
}

class CashPayment implements Payable {
    public void pay() {
        System.out.println("Cash on delivery");
    }
}

class UpiPayment implements Payable{
    public void pay() {
        System.out.println("Online Payment");
    }
}

class WalletPayment implements Payable {
    public void pay() {
        System.out.println("Wallet Payment");
    }
}

public class Main {
    public static void main(String[] args) {
        Payable payment = new UpiPayment();  
        payment.pay();
    }
}


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---> Liskov Substituion principle:
-----------------------------

* If class B is a subclass of class A, then objects of type A can be replaced with objects of type B without affecting the correctness of the program.

valid example for liskov Substitution principle:
----------------------------------------------

class Bird {
    void fly() {
        System.out.println("Bird is flying");
    }
}

class Sparrow extends Bird {
    @Override
    void fly() {
        System.out.println("Sparrow flies fast");
    }
}

public class Test {
    public static void main(String[] args) {
        Bird b = new Sparrow(); // Parent ref, child object
        b.fly(); // Works perfectly → behaviour correct
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Invalid example for liskov substitution principle :
---------------------------------------------------

class Bird {
    void fly() {
        System.out.println("Bird is flying");
    }
}

class Ostrich extends Bird { // Ostrich can't fly!
    @Override
    void fly() {
        throw new UnsupportedOperationException("Ostrich can't fly");
    }
}

public class Test {
    public static void main(String[] args) {
        Bird b = new Ostrich(); // Parent ref, child object
        b.fly(); // Unexpected exception → LSP broken
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---> Interface Segregation : 
     -----------------------

Clients should not be forced to depend on interfaces they do not use.
In other words, split big, fat interfaces into smaller, specific ones so that a class only implements what it actually needs.

valid Example for Interface Segregation : 
----------------------------------------
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Robot implements Workable {
    public void work() {
        System.out.println("Robot working...");
    }
}

class Human implements Workable, Eatable {
    public void work() {
        System.out.println("Human working...");
    }
    public void eat() {
        System.out.println("Human eating...");
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Invalid example for Interface Segregation : 
------------------------------------------

interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() {
        System.out.println("Robot working...");
    }
    public void eat() { // Robot doesn't eat, but forced to implement
        throw new UnsupportedOperationException("Robot can't eat");
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Dependency Inversion Principle (DIP):
------------------------------------

--> High-level modules should not depend on low-level modules. Both should depend on abstractions.

valid example for DIP :
-----------------------
// Abstraction (Contract)
interface BeverageMaker {
    void makeBeverage();
}

// Low-level module 1
class TeaMaker implements BeverageMaker {
    public void makeBeverage() {
        System.out.println("Making tea");
    }
}

// Low-level module 2
class CoffeeMaker implements BeverageMaker {
    public void makeBeverage() {
        System.out.println("Making coffee");
    }
}

// High-level module
class Manager {
    private BeverageMaker maker; // Depends on abstraction

    public Manager(BeverageMaker maker) {
        this.maker = maker;
    }

    public void serveCustomer() {
        maker.makeBeverage();
    }
}

public class Main {
    public static void main(String[] args) {
        // Manager can easily work with any beverage
        BeverageMaker teaMaker = new TeaMaker();
        BeverageMaker coffeeMaker = new CoffeeMaker();

        Manager teaManager = new Manager(teaMaker);
        teaManager.serveCustomer(); // Making tea

        Manager coffeeManager = new Manager(coffeeMaker);
        coffeeManager.serveCustomer(); // Making coffee
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------
Invalid principle for DIP :
--------------------------

// Abstraction (Contract)
interface BeverageMaker {
    void makeBeverage();
}

// Low-level module 1
class TeaMaker implements BeverageMaker {
    public void makeBeverage() {
        System.out.println("Making tea");
    }
}

// Low-level module 2
class CoffeeMaker implements BeverageMaker {
    public void makeBeverage() {
        System.out.println("Making coffee");
    }
}

// High-level module
class Manager {
    private BeverageMaker maker; // Depends on abstraction

    public Manager(BeverageMaker maker) {
        this.maker = maker;
    }

    public void serveCustomer() {
        maker.makeBeverage();
    }
}

public class Main {
    public static void main(String[] args) {
        // Manager can easily work with any beverage
        BeverageMaker teaMaker = new TeaMaker();
        BeverageMaker coffeeMaker = new CoffeeMaker();

        Manager teaManager = new Manager(teaMaker);
        teaManager.serveCustomer(); // Making tea

        Manager coffeeManager = new Manager(coffeeMaker);
        coffeeManager.serveCustomer(); // Making coffee
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


